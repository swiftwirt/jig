{"entries":[{"timestamp":1758228466864,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":185,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":33,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":226,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1758228916939,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":156,"diffs":[[1,""]]},{"start1":28,"length1":78,"diffs":[[1,"\t\n})\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":199,"length1":63,"diffs":[[1,"        \"README.md\"\n"]]}]},{"type":"added","filename":"motion.ts","value":"namespace Robot.Hardware.Motors {\n    // Motor driver pin assignments (new H-bridge configuration)\n    const STBY = DigitalPin.P8;\n    const LEFT_PWM = AnalogPin.P0;\n    const LEFT_IN1 = DigitalPin.P1;\n    const LEFT_IN2 = DigitalPin.P2;\n    const RIGHT_PWM = AnalogPin.P14;\n    const RIGHT_IN1 = DigitalPin.P12;\n    const RIGHT_IN2 = DigitalPin.P13;\n\n    const ARROW_FWD = ArrowNames.North;\n    const ARROW_REV = ArrowNames.South;\n    const ARROW_SPIN_L = ArrowNames.West;\n    const ARROW_SPIN_R = ArrowNames.East;\n    const ARROW_TURN_L = ArrowNames.NorthWest;\n    const ARROW_TURN_R = ArrowNames.NorthEast;\n    const ARROW_TURN_L_REV = ArrowNames.SouthWest;\n    const ARROW_TURN_R_REV = ArrowNames.SouthEast;\n\n    const MAX_SPEED_L = 935;\n    const MAX_SPEED_R = 1023;\n    const TURN_SCALE_NUM = 4;\n    const TURN_SCALE_DEN = 10;\n    export const SAFE_DISTANCE = 40;\n    export const ACTIVE_BRAKE_MS = 100;\n\n    export let motorsRunning = false;\n    export let currentDir = 0;        // +1 forward, -1 backward, 0 spin/stop\n\n    // ─── MOTION FUNCTIONS ───────────────────────────────────────────────────────\n    export function forward() {\n        if (Robot.Hardware.Sensors.frontDistance < SAFE_DISTANCE) {\n            stop(); Robot.Services.Display.showIconIfChanged(IconNames.No);\n            return;\n        }\n        writeWheels(MAX_SPEED_L, 0, MAX_SPEED_R, 0);\n        Robot.Services.Display.showArrowIfChanged(ARROW_FWD);\n        motorsRunning = true;\n        currentDir = 1;\n    }\n\n    export function backward() {\n        writeWheels(0, MAX_SPEED_L, 0, MAX_SPEED_R);\n        Robot.Services.Display.showArrowIfChanged(ARROW_REV);\n        motorsRunning = true;\n        currentDir = -1;\n    }\n\n    export function spinLeft() {\n        writeWheels(MAX_SPEED_L, 0, 0, MAX_SPEED_R);\n        Robot.Services.Display.showArrowIfChanged(ARROW_SPIN_L);\n        motorsRunning = true;\n        currentDir = 0;\n    }\n\n    export function spinRight() {\n        writeWheels(0, MAX_SPEED_L, MAX_SPEED_R, 0);\n        Robot.Services.Display.showArrowIfChanged(ARROW_SPIN_R);\n        motorsRunning = true;\n        currentDir = 0;\n    }\n\n    export function turnLeft() {\n        if (Robot.Hardware.Sensors.frontDistance < SAFE_DISTANCE) {\n            stop(); Robot.Services.Display.showIconIfChanged(IconNames.No);\n            return;\n        }\n        const slow = Math.idiv(MAX_SPEED_L * TURN_SCALE_NUM, TURN_SCALE_DEN);\n        writeWheels(slow, 0, MAX_SPEED_R, 0);\n        Robot.Services.Display.showArrowIfChanged(ARROW_TURN_L);\n        motorsRunning = true;\n        currentDir = 1;\n    }\n\n    export function turnRight() {\n        if (Robot.Hardware.Sensors.frontDistance < SAFE_DISTANCE) {\n            stop(); Robot.Services.Display.showIconIfChanged(IconNames.No);\n            return;\n        }\n        const slow = Math.idiv(MAX_SPEED_R * TURN_SCALE_NUM, TURN_SCALE_DEN);\n        writeWheels(MAX_SPEED_R, 0, slow, 0);\n        Robot.Services.Display.showArrowIfChanged(ARROW_TURN_R);\n        motorsRunning = true;\n        currentDir = 1;\n    }\n\n    export function turnLeftBackward() {\n        const slow = Math.idiv(MAX_SPEED_L * TURN_SCALE_NUM, TURN_SCALE_DEN);\n        writeWheels(0, slow, 0, MAX_SPEED_R);\n        Robot.Services.Display.showArrowIfChanged(ARROW_TURN_L_REV);\n        motorsRunning = true;\n        currentDir = -1;\n    }\n\n    export function turnRightBackward() {\n        const slow = Math.idiv(MAX_SPEED_R * TURN_SCALE_NUM, TURN_SCALE_DEN);\n        writeWheels(0, MAX_SPEED_L, 0, slow);\n        Robot.Services.Display.showArrowIfChanged(ARROW_TURN_R_REV);\n        motorsRunning = true;\n        currentDir = -1;\n    }\n\n    // ─── LOW-LEVEL MOTOR CONTROL ────────────────────────────────────────────────\n    export function writeWheels(Lf: number, Lb: number, Rf: number, Rb: number) {\n        // Enable motor driver\n        pins.digitalWritePin(STBY, 1);\n\n        // Left motor control\n        if (Lf > 0) {\n            pins.digitalWritePin(LEFT_IN1, 1);\n            pins.digitalWritePin(LEFT_IN2, 0);\n            pins.analogWritePin(LEFT_PWM, Lf);\n        } else if (Lb > 0) {\n            pins.digitalWritePin(LEFT_IN1, 0);\n            pins.digitalWritePin(LEFT_IN2, 1);\n            pins.analogWritePin(LEFT_PWM, Lb);\n        } else {\n            pins.digitalWritePin(LEFT_IN1, 0);\n            pins.digitalWritePin(LEFT_IN2, 0);\n            pins.analogWritePin(LEFT_PWM, 0);\n        }\n\n        // Right motor control\n        if (Rf > 0) {\n            pins.digitalWritePin(RIGHT_IN1, 1);\n            pins.digitalWritePin(RIGHT_IN2, 0);\n            pins.analogWritePin(RIGHT_PWM, Rf);\n        } else if (Rb > 0) {\n            pins.digitalWritePin(RIGHT_IN1, 0);\n            pins.digitalWritePin(RIGHT_IN2, 1);\n            pins.analogWritePin(RIGHT_PWM, Rb);\n        } else {\n            pins.digitalWritePin(RIGHT_IN1, 0);\n            pins.digitalWritePin(RIGHT_IN2, 0);\n            pins.analogWritePin(RIGHT_PWM, 0);\n        }\n    }\n\n    export function brakePulse() {\n        if (!ACTIVE_BRAKE_MS) return;\n        const pulse = Math.idiv(((MAX_SPEED_L + MAX_SPEED_R) / 2), 2);\n        writeWheels(\n            currentDir > 0 ? 0 : pulse,\n            currentDir > 0 ? pulse : 0,\n            currentDir > 0 ? 0 : pulse,\n            currentDir > 0 ? pulse : 0\n        );\n        basic.pause(ACTIVE_BRAKE_MS);\n    }\n\n    export function stop() {\n        if (motorsRunning) brakePulse();\n        // Disable motor driver and set all outputs to 0\n        pins.digitalWritePin(STBY, 0);\n        pins.digitalWritePin(LEFT_IN1, 0);\n        pins.digitalWritePin(LEFT_IN2, 0);\n        pins.analogWritePin(LEFT_PWM, 0);\n        pins.digitalWritePin(RIGHT_IN1, 0);\n        pins.digitalWritePin(RIGHT_IN2, 0);\n        pins.analogWritePin(RIGHT_PWM, 0);\n        motorsRunning = false;\n        Robot.Services.Display.showIconIfChanged(Robot.Core.State.connected ? IconNames.Happy : IconNames.Skull);\n    }\n\n    // ─── MOTION TESTS ────────────────────────────────────────────────────────────\n    export function runTests(): boolean {\n        let passed = 0;\n        let total = 0;\n\n        // Test 1: Stop function works\n        total++;\n        stop();\n        if (!motorsRunning) passed++;\n\n        // Test 2: Constants are correct\n        total++;\n        if (SAFE_DISTANCE === 40 && ACTIVE_BRAKE_MS === 100) passed++;\n\n        // Test 3: Direction tracking works\n        total++;\n        stop();\n        if (currentDir === 0) passed++;\n\n        // Test 4: Motor functions exist and don't crash\n        total++;\n        try {\n            forward();\n            basic.pause(50);\n            stop();\n            backward();\n            basic.pause(50);\n            stop();\n            spinLeft();\n            basic.pause(50);\n            stop();\n            spinRight();\n            basic.pause(50);\n            stop();\n            passed++;\n        } catch (e) {\n            // Function calls failed\n        }\n\n        basic.showString(`M:${passed}/${total}`);\n        return passed === total;\n    }\n}"},{"type":"added","filename":"display.ts","value":"namespace Robot.Display {\n    // ─── UTILITY DISPLAY ─────────────────────────────────────────────────────────\n    let lastDisplayType = \"\";\n    let lastDisplayValue = -1;\n\n    export function showArrowIfChanged(a: ArrowNames) {\n        if (lastDisplayType !== \"arrow\" || lastDisplayValue !== a) {\n            basic.showArrow(a);\n            lastDisplayType = \"arrow\";\n            lastDisplayValue = a;\n        }\n    }\n\n    export function showIconIfChanged(i: IconNames) {\n        if (lastDisplayType !== \"icon\" || lastDisplayValue !== i) {\n            basic.showIcon(i);\n            lastDisplayType = \"icon\";\n            lastDisplayValue = i;\n        }\n    }\n}\n\nnamespace Robot.Observer {\n    let cpuTemp = 0;\n    let lastCpuTemp = -999;\n    let lastFront = -1;\n    let lastBack = -1;\n\n    export function sendTelemetry() {\n        cpuTemp = input.temperature();\n\n        const changed =\n            cpuTemp !== lastCpuTemp ||\n            Robot.Sonar.frontDistance !== lastFront ||\n            Robot.Sonar.backDistance !== lastBack;\n\n        if (!changed) return;\n\n        lastCpuTemp = cpuTemp;\n        lastFront = Robot.Sonar.frontDistance;\n        lastBack = Robot.Sonar.backDistance;\n\n        let p = {\n            cpu: cpuTemp,\n            front: Robot.Sonar.frontDistance,\n            back: Robot.Sonar.backDistance\n        };\n\n        bluetooth.uartWriteString(JSON.stringify(p) + \"\\n\");\n    }\n}"}]},{"timestamp":1758229410039,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":105,"length1":59,"diffs":[[1,"Robot.Display.showIconIfChanged(IconNames.Happy);\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":241,"length1":41,"diffs":[[1,"        \"display.ts\"\n"]]}]},{"type":"edited","filename":"display.ts","patch":[{"start1":0,"length1":35,"diffs":[[1,"namespace Robot.Display {\n"]]},{"start1":661,"length1":0,"diffs":[[1,"}\n\nnamespace Robot.Observer {\n    let cpuTemp = 0;\n    let lastCpuTemp = -999;\n    let lastFront = -1;\n    let lastBack = -1;\n\n    export function sendTelemetry() {\n        cpuTemp = input.temperature();\n\n        const changed =\n            cpuTemp !== lastCpuTemp ||\n            Robot.Sonar.frontDistance !== lastFront ||\n            Robot.Sonar.backDistance !== lastBack;\n\n        if (!changed) return;\n\n        lastCpuTemp = cpuTemp;\n        lastFront = Robot.Sonar.frontDistance;\n        lastBack = Robot.Sonar.backDistance;\n\n        let p = {\n            cpu: cpuTemp,\n            front: Robot.Sonar.frontDistance,\n            back: Robot.Sonar.backDistance\n        };\n\n        bluetooth.uartWriteString(JSON.stringify(p) + \"\\n\");\n    }\n"]]}]},{"type":"added","filename":"sonar.ts","value":"namespace Robot.Hardware.Sensors {\n    const SONAR_RETRY = 2;\n    const SENSOR_INTERVAL_MS = 100;      // 80–120ms is fine\n    const MIN_CM = 2;\n    const MAX_CM = 300;\n\n    export let frontDistance = 999;\n    let lastGood = 999;\n\n    // Configure echo so it doesn't float\n    pins.setPull(DigitalPin.P16, PinPullMode.PullDown);\n\n    function pingOnce(trigger: DigitalPin, echo: DigitalPin): number {\n        // Optional: tiny settle time\n        basic.pause(1);\n        let d = sonar.ping(trigger, echo, PingUnit.Centimeters);\n        return d > 0 ? d : 0;\n    }\n\n    function robustPing(trigger: DigitalPin, echo: DigitalPin): number {\n        // quick retries\n        let best = 0;\n        for (let i = 0; i <= SONAR_RETRY; i++) {\n            const d = pingOnce(trigger, echo);\n            if (d > 0) { best = d; break; }\n            basic.pause(4);\n        }\n        return best;\n    }\n\n    function medianOf3(a: number, b: number, c: number): number {\n        const arr = [a, b, c];\n        arr.sort((x, y) => x - y);\n        return arr[1];\n    }\n\n    function readFiltered(trigger: DigitalPin, echo: DigitalPin): number {\n        const a = robustPing(trigger, echo);\n        const b = robustPing(trigger, echo);\n        const c = robustPing(trigger, echo);\n        let m = medianOf3(a, b, c);\n\n        // range check + simple hold-last-good\n        if (m === 0 || m < MIN_CM || m > MAX_CM) return lastGood;\n        lastGood = m;\n        return m;\n    }\n\n    basic.forever(function () {\n        // If PWM is active/noisy, you can skip or delay the ping:\n        // if (Robot.Hardware.Motors.motorsRunning) { basic.pause(SENSOR_INTERVAL_MS); return; }\n\n        frontDistance = readFiltered(DigitalPin.P15, DigitalPin.P16);\n\n        // safety stop\n        if (Robot.Hardware.Motors.currentDir > 0\n            && frontDistance < Robot.Hardware.Motors.SAFE_DISTANCE) {\n            Robot.Hardware.Motors.stop();\n        }\n\n        basic.pause(SENSOR_INTERVAL_MS);\n    });\n}"}]},{"timestamp":1758229774146,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":187,"diffs":[[1,"// ─── STATE ───────────────────────────────────────────────────────────────────\nlet connected = false;\n"]]},{"start1":105,"length1":146,"diffs":[[1,"Robot.Services.Display.showIconIfChanged(IconNames.Happy);\n"]]},{"start1":165,"length1":668,"diffs":[[1,""]]},{"start1":193,"length1":77,"diffs":[[1,"    if (connected) Robot.Observer.sendTelemetry();\n"]]},{"start1":267,"length1":3,"diffs":[[1,"});\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":263,"length1":42,"diffs":[[1,"        \"sonar.ts\"\n"]]}]},{"type":"edited","filename":"motion.ts","patch":[{"start1":1144,"length1":66,"diffs":[[1,"        if (Robot.Hardware.Sensors.frontDistance < SAFE_DISTANCE) {\n"]]},{"start1":1527,"length1":172,"diffs":[[1,""]]},{"start1":2162,"length1":66,"diffs":[[1,"        if (Robot.Hardware.Sensors.frontDistance < SAFE_DISTANCE) {\n"]]},{"start1":2620,"length1":66,"diffs":[[1,"        if (Robot.Hardware.Sensors.frontDistance < SAFE_DISTANCE) {\n"]]},{"start1":3085,"length1":172,"diffs":[[1,""]]},{"start1":3382,"length1":172,"diffs":[[1,""]]}]},{"type":"edited","filename":"sonar.ts","patch":[{"start1":0,"length1":33,"diffs":[[1,"namespace Robot.Hardware.Sensors {\n"]]}]},{"type":"added","filename":"observer.ts","value":"namespace Robot.Services.Reporter {\n    // ─── TELEMETRY ───────────────────────────────────────────────────────────────\n    let cpuTemp = 0;\n    let ambientTemp = 0;\n    let humidity = 0;\n\n    let lastCpuTemp = -999;\n    let lastFront = -1;\n    let lastAmbient = 999;\n    let lastHumidity = 999;\n\n    export function sendTelemetry() {\n        cpuTemp = input.temperature();\n\n        const changed =\n            cpuTemp !== lastCpuTemp ||\n            Robot.Hardware.Sonar.frontDistance !== lastFront ||\n            ambientTemp !== lastAmbient ||\n            humidity !== lastHumidity;\n\n        if (!changed) return;\n\n        lastCpuTemp = cpuTemp;\n        lastFront = Robot.Hardware.Sonar.frontDistance;\n        lastAmbient = ambientTemp;\n        lastHumidity = humidity;\n\n        let p = {\n            cpu: cpuTemp,\n            ambient: ambientTemp,\n            humidity: humidity,\n            front: Robot.Hardware.Sonar.frontDistance\n        };\n\n        bluetooth.uartWriteString(JSON.stringify(p) + \"\\n\");\n    }\n}"}]},{"timestamp":1758230320873,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":283,"length1":65,"diffs":[[1,"        \"observer.ts\"\n"]]}]},{"type":"edited","filename":"motion.ts","patch":[{"start1":911,"length1":6,"diffs":[[1,""]]}]},{"type":"added","filename":"ble.ts","value":"namespace Robot.Core.Bluetooth {\n    // ─── BLUETOOTH UART SETUP ───────────────────────────────────────────────────\n    const TX_POWER_MAX = 7;\n    const NEWLINE = serial.delimiters(Delimiters.NewLine);\n\n    bluetooth.startUartService();\n    bluetooth.setTransmitPower(TX_POWER_MAX);\n\n    bluetooth.onBluetoothConnected(() => {\n        connected = true;\n        Robot.Display.showIconIfChanged(IconNames.Heart);\n    });\n\n    bluetooth.onBluetoothDisconnected(() => {\n        connected = false;\n        Robot.Display.showIconIfChanged(IconNames.Sad);\n    });\n\n    bluetooth.onUartDataReceived(NEWLINE, () => {\n        let cmd = bluetooth.uartReadUntil(NEWLINE).trim();\n        Robot.Core.Dispatcher.dispatch(cmd);\n    });\n}"},{"type":"added","filename":"dispatcher.ts","value":"namespace Robot.Core.Dispatcher {\n    export function dispatch(cmd: string) {\n        // Try to parse as JSON settings message first\n        if (!tryParseSettingsMessage(cmd)) {\n            // Handle existing numeric commands\n            executeCmd(cmd)\n        }\n    }\n\n    // ─── SETTINGS MESSAGE HANDLING ──────────────────────────────────────────────\n    function tryParseSettingsMessage(cmd: string): boolean {\n        try {\n            // Try to parse as JSON\n            const parsed = JSON.parse(cmd);\n\n            // format: {\"l\":X,\"r\":Y,\"f\":Z,\"b\":W}\n            if (parsed && typeof parsed === \"object\") {\n                let processed = false;\n\n                // Process motor speeds if both are provided\n                if (typeof parsed.l === \"number\" && typeof parsed.r === \"number\") {\n                    const leftSpeed = parsed.l;\n                    const rightSpeed = parsed.r;\n\n                    // Validate and apply motor speeds\n                    if (leftSpeed >= 0 && leftSpeed <= 1023 && rightSpeed >= 0 && rightSpeed <= 1023) {\n                        Robot.Hardware.Motors.setMotorSpeeds(leftSpeed, rightSpeed);\n                        processed = true;\n                    }\n                }\n\n                // Process safe distances if both are provided\n                if (typeof parsed.f === \"number\" && typeof parsed.b === \"number\") {\n                    const frontDistance = parsed.f;\n                    const backDistance = parsed.b;\n\n                    basic.showString(frontDistance, 100);\n                    basic.showString(backDistance, 100);\n\n                    // Validate and apply safe distances (20-100cm range)\n                    if (frontDistance >= 20 && frontDistance <= 100 && backDistance >= 5 && backDistance <= 200) {\n                        Robot.Hardware.Motors.setSafeDistances(frontDistance, backDistance);\n                        processed = true;\n                    }\n                }\n\n                return processed;\n            }\n            return false;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    function executeCmd(cmd: string) {\n        switch (cmd) {\n            case \"1\": Robot.Hardware.Motors.forward(); break;\n            case \"2\": Robot.Hardware.Motors.backward(); break;\n            case \"3\": Robot.Hardware.Motors.spinLeft(); break;\n            case \"4\": Robot.Hardware.Motors.spinRight(); break;\n            case \"5\": Robot.Hardware.Motors.turnLeft(); break;\n            case \"6\": Robot.Hardware.Motors.turnRight(); break;\n            case \"7\": Robot.Hardware.Motors.turnLeftBackward(); break;\n            case \"8\": Robot.Hardware.Motors.turnRightBackward(); break;\n            default: Robot.Hardware.Motors.stop(); break;\n        }\n    }\n}"}]},{"timestamp":1758230919928,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":87,"length1":132,"diffs":[[1,"        \"radio\": \"*\",\n        \"microphone\": \"*\"\n"]]},{"start1":324,"length1":44,"diffs":[[1,"        \"dispatcher.ts\"\n"]]},{"start1":355,"length1":326,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]},{"type":"edited","filename":"motion.ts","patch":[{"start1":713,"length1":28,"diffs":[[1,"    const MAX_SPEED_L = 935;\n    const MAX_SPEED_R = 1023;\n"]]},{"start1":833,"length1":45,"diffs":[[1,"    export const SAFE_DISTANCE = 40;\n"]]},{"start1":911,"length1":0,"diffs":[[1,"    \n\n"]]},{"start1":1034,"length1":2926,"diffs":[[1,""]]}]},{"type":"edited","filename":"ble.ts","patch":[{"start1":329,"length1":112,"diffs":[[1,"        connected = true;\n        Robot.Display.showIconIfChanged(IconNames.Heart);\n"]]},{"start1":468,"length1":111,"diffs":[[1,"        connected = false;\n        Robot.Display.showIconIfChanged(IconNames.Sad);\n"]]}]},{"type":"added","filename":"servo.ts","value":"// Add your code here\n"}]},{"timestamp":1758231469538,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":459,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1758228466863,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"jig\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1758230270596,"editorVersion":"8.0.16","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"namespace Robot.Core.State {\n    // ─── GLOBAL STATE ─────────────────────────────────────────────────────────\n    export let connected = false;\n    music.setBuiltInSpeakerEnabled(false)\n\n    export function setConnected(value: boolean) {\n        connected = value;\n        Robot.Core.Events.emit(\"connectionChanged\", value);\n    }\n}\n\nnamespace Robot.Core.Events {\n    // ─── EVENT SYSTEM ─────────────────────────────────────────────────────────\n    type EventCallback = (data?: any) => void;\n    let listeners: { [event: string]: EventCallback[] } = {};\n\n    export function on(event: string, callback: EventCallback) {\n        if (!listeners[event]) listeners[event] = [];\n        listeners[event].push(callback);\n    }\n\n    export function emit(event: string, data?: any) {\n        if (listeners[event]) {\n            for (let callback of listeners[event]) {\n                callback(data);\n            }\n        }\n    }\n}\n\n// ─── MAIN RUNLOOP ──────────────────────────────────────────────────────\nbasic.forever(function () {\n    if (Robot.Core.State.connected) Robot.Services.Reporter.sendTelemetry();\n    basic.pause(1000);\n});","README.md":"","motion.ts":"namespace Robot.Hardware.Motors {\n    // Motor driver pin assignments (new H-bridge configuration)\n    const STBY = DigitalPin.P8;\n    const LEFT_PWM = AnalogPin.P0;\n    const LEFT_IN1 = DigitalPin.P1;\n    const LEFT_IN2 = DigitalPin.P2;\n    const RIGHT_PWM = AnalogPin.P14;\n    const RIGHT_IN1 = DigitalPin.P12;\n    const RIGHT_IN2 = DigitalPin.P13;\n\n    const ARROW_FWD = ArrowNames.North;\n    const ARROW_REV = ArrowNames.South;\n    const ARROW_SPIN_L = ArrowNames.West;\n    const ARROW_SPIN_R = ArrowNames.East;\n    const ARROW_TURN_L = ArrowNames.NorthWest;\n    const ARROW_TURN_R = ArrowNames.NorthEast;\n    const ARROW_TURN_L_REV = ArrowNames.SouthWest;\n    const ARROW_TURN_R_REV = ArrowNames.SouthEast;\n\n    const MAX_SPEED_L = 935;\n    const MAX_SPEED_R = 1023;\n    const TURN_SCALE_NUM = 4;\n    const TURN_SCALE_DEN = 10;\n    export const SAFE_DISTANCE = 40;\n    export const ACTIVE_BRAKE_MS = 100;\n\n    export let motorsRunning = false;\n    export let currentDir = 0;        // +1 forward, -1 backward, 0 spin/stop\n\n    // ─── MOTION FUNCTIONS ───────────────────────────────────────────────────────\n    export function forward() {\n        if (Robot.Hardware.Sensors.frontDistance < SAFE_DISTANCE) {\n            stop(); Robot.Services.Display.showIconIfChanged(IconNames.No);\n            return;\n        }\n        writeWheels(MAX_SPEED_L, 0, MAX_SPEED_R, 0);\n        Robot.Services.Display.showArrowIfChanged(ARROW_FWD);\n        motorsRunning = true;\n        currentDir = 1;\n    }\n\n    export function backward() {\n        writeWheels(0, MAX_SPEED_L, 0, MAX_SPEED_R);\n        Robot.Services.Display.showArrowIfChanged(ARROW_REV);\n        motorsRunning = true;\n        currentDir = -1;\n    }\n\n    export function spinLeft() {\n        writeWheels(MAX_SPEED_L, 0, 0, MAX_SPEED_R);\n        Robot.Services.Display.showArrowIfChanged(ARROW_SPIN_L);\n        motorsRunning = true;\n        currentDir = 0;\n    }\n\n    export function spinRight() {\n        writeWheels(0, MAX_SPEED_L, MAX_SPEED_R, 0);\n        Robot.Services.Display.showArrowIfChanged(ARROW_SPIN_R);\n        motorsRunning = true;\n        currentDir = 0;\n    }\n\n    export function turnLeft() {\n        if (Robot.Hardware.Sonar.frontDistance < SAFE_DISTANCE) {\n            stop(); Robot.Services.Display.showIconIfChanged(IconNames.No);\n            return;\n        }\n        const slow = Math.idiv(MAX_SPEED_L * TURN_SCALE_NUM, TURN_SCALE_DEN);\n        writeWheels(slow, 0, MAX_SPEED_R, 0);\n        Robot.Services.Display.showArrowIfChanged(ARROW_TURN_L);\n        motorsRunning = true;\n        currentDir = 1;\n    }\n\n    export function turnRight() {\n        if (Robot.Hardware.Sonar.frontDistance < SAFE_DISTANCE) {\n            stop(); Robot.Services.Display.showIconIfChanged(IconNames.No);\n            return;\n        }\n        const slow = Math.idiv(MAX_SPEED_R * TURN_SCALE_NUM, TURN_SCALE_DEN);\n        writeWheels(MAX_SPEED_R, 0, slow, 0);\n        Robot.Services.Display.showArrowIfChanged(ARROW_TURN_R);\n        motorsRunning = true;\n        currentDir = 1;\n    }\n\n    export function turnLeftBackward() {\n        const slow = Math.idiv(MAX_SPEED_L * TURN_SCALE_NUM, TURN_SCALE_DEN);\n        writeWheels(0, slow, 0, MAX_SPEED_R);\n        Robot.Services.Display.showArrowIfChanged(ARROW_TURN_L_REV);\n        motorsRunning = true;\n        currentDir = -1;\n    }\n\n    export function turnRightBackward() {\n        const slow = Math.idiv(MAX_SPEED_R * TURN_SCALE_NUM, TURN_SCALE_DEN);\n        writeWheels(0, MAX_SPEED_L, 0, slow);\n        Robot.Services.Display.showArrowIfChanged(ARROW_TURN_R_REV);\n        motorsRunning = true;\n        currentDir = -1;\n    }\n\n    // ─── LOW-LEVEL MOTOR CONTROL ────────────────────────────────────────────────\n    export function writeWheels(Lf: number, Lb: number, Rf: number, Rb: number) {\n        // Enable motor driver\n        pins.digitalWritePin(STBY, 1);\n\n        // Left motor control\n        if (Lf > 0) {\n            pins.digitalWritePin(LEFT_IN1, 1);\n            pins.digitalWritePin(LEFT_IN2, 0);\n            pins.analogWritePin(LEFT_PWM, Lf);\n        } else if (Lb > 0) {\n            pins.digitalWritePin(LEFT_IN1, 0);\n            pins.digitalWritePin(LEFT_IN2, 1);\n            pins.analogWritePin(LEFT_PWM, Lb);\n        } else {\n            pins.digitalWritePin(LEFT_IN1, 0);\n            pins.digitalWritePin(LEFT_IN2, 0);\n            pins.analogWritePin(LEFT_PWM, 0);\n        }\n\n        // Right motor control\n        if (Rf > 0) {\n            pins.digitalWritePin(RIGHT_IN1, 1);\n            pins.digitalWritePin(RIGHT_IN2, 0);\n            pins.analogWritePin(RIGHT_PWM, Rf);\n        } else if (Rb > 0) {\n            pins.digitalWritePin(RIGHT_IN1, 0);\n            pins.digitalWritePin(RIGHT_IN2, 1);\n            pins.analogWritePin(RIGHT_PWM, Rb);\n        } else {\n            pins.digitalWritePin(RIGHT_IN1, 0);\n            pins.digitalWritePin(RIGHT_IN2, 0);\n            pins.analogWritePin(RIGHT_PWM, 0);\n        }\n    }\n\n    export function brakePulse() {\n        if (!ACTIVE_BRAKE_MS) return;\n        const pulse = Math.idiv(((MAX_SPEED_L + MAX_SPEED_R) / 2), 2);\n        writeWheels(\n            currentDir > 0 ? 0 : pulse,\n            currentDir > 0 ? pulse : 0,\n            currentDir > 0 ? 0 : pulse,\n            currentDir > 0 ? pulse : 0\n        );\n        basic.pause(ACTIVE_BRAKE_MS);\n    }\n\n    export function stop() {\n        if (motorsRunning) brakePulse();\n        // Disable motor driver and set all outputs to 0\n        pins.digitalWritePin(STBY, 0);\n        pins.digitalWritePin(LEFT_IN1, 0);\n        pins.digitalWritePin(LEFT_IN2, 0);\n        pins.analogWritePin(LEFT_PWM, 0);\n        pins.digitalWritePin(RIGHT_IN1, 0);\n        pins.digitalWritePin(RIGHT_IN2, 0);\n        pins.analogWritePin(RIGHT_PWM, 0);\n        motorsRunning = false;\n        Robot.Services.Display.showIconIfChanged(Robot.Core.State.connected ? IconNames.Happy : IconNames.Skull);\n    }\n\n    // ─── MOTION TESTS ────────────────────────────────────────────────────────────\n    export function runTests(): boolean {\n        let passed = 0;\n        let total = 0;\n\n        // Test 1: Stop function works\n        total++;\n        stop();\n        if (!motorsRunning) passed++;\n\n        // Test 2: Constants are correct\n        total++;\n        if (SAFE_DISTANCE === 40 && ACTIVE_BRAKE_MS === 100) passed++;\n\n        // Test 3: Direction tracking works\n        total++;\n        stop();\n        if (currentDir === 0) passed++;\n\n        // Test 4: Motor functions exist and don't crash\n        total++;\n        try {\n            forward();\n            basic.pause(50);\n            stop();\n            backward();\n            basic.pause(50);\n            stop();\n            spinLeft();\n            basic.pause(50);\n            stop();\n            spinRight();\n            basic.pause(50);\n            stop();\n            passed++;\n        } catch (e) {\n            // Function calls failed\n        }\n\n        basic.showString(`M:${passed}/${total}`);\n        return passed === total;\n    }\n}","display.ts":"namespace Robot.Services.Display {\n    // ─── UTILITY DISPLAY ─────────────────────────────────────────────────────────\n    let lastDisplayType = \"\";\n    let lastDisplayValue = -1;\n\n    export function showArrowIfChanged(a: ArrowNames) {\n        if (lastDisplayType !== \"arrow\" || lastDisplayValue !== a) {\n            basic.showArrow(a);\n            lastDisplayType = \"arrow\";\n            lastDisplayValue = a;\n        }\n    }\n\n    export function showIconIfChanged(i: IconNames) {\n        if (lastDisplayType !== \"icon\" || lastDisplayValue !== i) {\n            basic.showIcon(i);\n            lastDisplayType = \"icon\";\n            lastDisplayValue = i;\n        }\n    }\n}","sonar.ts":"namespace Robot.Hardware.Sonar {\n    const SONAR_RETRY = 2;\n    const SENSOR_INTERVAL_MS = 100;      // 80–120ms is fine\n    const MIN_CM = 2;\n    const MAX_CM = 300;\n\n    export let frontDistance = 999;\n    let lastGood = 999;\n\n    // Configure echo so it doesn't float\n    pins.setPull(DigitalPin.P16, PinPullMode.PullDown);\n\n    function pingOnce(trigger: DigitalPin, echo: DigitalPin): number {\n        // Optional: tiny settle time\n        basic.pause(1);\n        let d = sonar.ping(trigger, echo, PingUnit.Centimeters);\n        return d > 0 ? d : 0;\n    }\n\n    function robustPing(trigger: DigitalPin, echo: DigitalPin): number {\n        // quick retries\n        let best = 0;\n        for (let i = 0; i <= SONAR_RETRY; i++) {\n            const d = pingOnce(trigger, echo);\n            if (d > 0) { best = d; break; }\n            basic.pause(4);\n        }\n        return best;\n    }\n\n    function medianOf3(a: number, b: number, c: number): number {\n        const arr = [a, b, c];\n        arr.sort((x, y) => x - y);\n        return arr[1];\n    }\n\n    function readFiltered(trigger: DigitalPin, echo: DigitalPin): number {\n        const a = robustPing(trigger, echo);\n        const b = robustPing(trigger, echo);\n        const c = robustPing(trigger, echo);\n        let m = medianOf3(a, b, c);\n\n        // range check + simple hold-last-good\n        if (m === 0 || m < MIN_CM || m > MAX_CM) return lastGood;\n        lastGood = m;\n        return m;\n    }\n\n    basic.forever(function () {\n        // If PWM is active/noisy, you can skip or delay the ping:\n        // if (Robot.Hardware.Motors.motorsRunning) { basic.pause(SENSOR_INTERVAL_MS); return; }\n\n        frontDistance = readFiltered(DigitalPin.P15, DigitalPin.P16);\n\n        // safety stop\n        if (Robot.Hardware.Motors.currentDir > 0\n            && frontDistance < Robot.Hardware.Motors.SAFE_DISTANCE) {\n            Robot.Hardware.Motors.stop();\n        }\n\n        basic.pause(SENSOR_INTERVAL_MS);\n    });\n}","observer.ts":"namespace Robot.Services.Reporter {\n    // ─── TELEMETRY ───────────────────────────────────────────────────────────────\n    let cpuTemp = 0;\n    let ambientTemp = 0;\n    let humidity = 0;\n\n    let lastCpuTemp = -999;\n    let lastFront = -1;\n    let lastAmbient = 999;\n    let lastHumidity = 999;\n\n    export function sendTelemetry() {\n        cpuTemp = input.temperature();\n\n        const changed =\n            cpuTemp !== lastCpuTemp ||\n            Robot.Hardware.Sonar.frontDistance !== lastFront ||\n            ambientTemp !== lastAmbient ||\n            humidity !== lastHumidity;\n\n        if (!changed) return;\n\n        lastCpuTemp = cpuTemp;\n        lastFront = Robot.Hardware.Sonar.frontDistance;\n        lastAmbient = ambientTemp;\n        lastHumidity = humidity;\n\n        let p = {\n            cpu: cpuTemp,\n            ambient: ambientTemp,\n            humidity: humidity,\n            front: Robot.Hardware.Sonar.frontDistance\n        };\n\n        bluetooth.uartWriteString(JSON.stringify(p) + \"\\n\");\n    }\n}","pxt.json":"{\n    \"name\": \"jig\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"motion.ts\",\n        \"display.ts\",\n        \"sonar.ts\",\n        \"observer.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1758231526683}